package server

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strconv"
	"strings"

	"github.com/google/uuid"
	"github.com/vk-rv/warnly/internal/warnly"
)

// ingestResponseError represents a standard API error response for event ingestion.
type ingestResponseError struct {
	Detail string `json:"detail"`
	//nolint:tagliatelle // keeping existing json tag for backward compatibility
	ErrorID string   `json:"errorId,omitempty"`
	Causes  []string `json:"causes,omitempty"`
}

// ingestResponseSuccess represents a standard API success response for event ingestion.
type ingestResponseSuccess struct {
	// The "id" field corresponds to the event ID submitted or that was generated by Warnly
	// if not provided in payload.
	ID string `json:"id"`
}

// EventHandler ingests events via API.
type EventHandler struct {
	svc    warnly.EventService
	logger *slog.Logger
}

// NewEventAPIHandler is a constructor of ventHandler.
func NewEventAPIHandler(svc warnly.EventService, logger *slog.Logger) *EventHandler {
	return &EventHandler{svc: svc, logger: logger}
}

// IngestEvent ingests new event.
func (h *EventHandler) IngestEvent(w http.ResponseWriter, r *http.Request) {
	res, err := h.handleIngestEvent(r)
	if err != nil {
		id := warnly.MustNanoID()
		h.logger.Error("ingest new event", slog.Any("error", err), slog.String("errorId", id))
		w.WriteHeader(http.StatusInternalServerError)
		if err := json.NewEncoder(w).Encode(ingestResponseError{
			Detail:  err.Error(),
			ErrorID: id,
		}); err != nil {
			h.logger.Error("encode error response", slog.Any("error", err))
		}
		return
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(ingestResponseSuccess{
		ID: res.EventID,
	}); err != nil {
		h.logger.Error("encode success response", slog.Any("error", err))
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

// handleIngestEvent handles the actual logic of ingesting an event.
func (h *EventHandler) handleIngestEvent(r *http.Request) (warnly.IngestEventResult, error) {
	ctx := r.Context()

	res := warnly.IngestEventResult{}

	projectID, err := strconv.Atoi(r.PathValue("project_id"))
	if err != nil {
		return res, fmt.Errorf("parse project id: %w", err)
	}

	b, err := io.ReadAll(r.Body)
	if err != nil {
		return res, fmt.Errorf("read body: %w", err)
	}

	lines := strings.Split(string(b), "\n")
	if len(lines) < 3 {
		return res, fmt.Errorf("split body: %w", err)
	}

	content := lines[2]

	event := warnly.EventBody{}
	if err := json.Unmarshal([]byte(content), &event); err != nil {
		return res, fmt.Errorf("unmarshal body: %w", err)
	}
	if event.EventID == "" {
		id := uuid.New()
		event.EventID = hex.EncodeToString(id[:])
	}

	req := warnly.IngestRequest{
		Event:     &event,
		ProjectID: projectID,
		IP:        r.RemoteAddr,
	}

	res, err = h.svc.IngestEvent(ctx, req)
	if err != nil {
		return res, fmt.Errorf("ingest event: %w", err)
	}

	return res, nil
}
